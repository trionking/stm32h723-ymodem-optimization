# AI 코딩 어시스턴트 활용 교훈

**작성일**: 2025-01-08
**프로젝트**: STM32H723 오디오 멀티플렉서 펌웨어

---

## 배경

SPI 데이터 전송 테스트 중 USB CDC 출력 문제를 해결하는 과정에서 발견한 근본적인 문제:
- SPI가 DMA 모드로 구현되어 있었으나, 실제로는 폴링 모드로 충분했음
- 사용자는 DMA로 구현되어 있는지조차 인지하지 못함
- 여러 세션에 걸쳐 미묘하게 이상한 방향으로 코드가 변경됨

---

## 1. AI 코딩의 구조적 문제

### 1.1 과도한 엔지니어링 (Over-engineering)

**문제 발생 메커니즘:**
```
사용자 요구: "SPI로 데이터 전송"
  ↓
AI 판단: "대용량 데이터 → DMA가 best practice!"
  ↓
결과: 불필요한 복잡도 증가
```

**실제 상황:**
- SPI Master 1개만 사용
- 순차 전송만 필요
- 동시 전송 없음
- → **폴링 모드로 충분**

**AI의 판단 실수:**
- ✅ "대용량 데이터" 인식 - 맞음
- ❌ "DMA 필수" 판단 - 틀림
- ❌ 복잡도 vs 이점 분석 누락

### 1.2 세션 단절 시 일관성 상실

**타임라인:**
```
세션 1: DMA 기반 구현 → 코드 작성
  ↓ [Claude 중지/리셋]
세션 2: 이전 컨텍스트 손실 → "왜 DMA를 썼지?" 파악 못함
  ↓
세션 3: 증상만 보고 땜질 (printf, uart_send_response 추가)
  ↓ [Claude 완전 중지]
세션 4: 모든 컨텍스트 손실 → 엉뚱한 방향 갈 위험
  ↓
사용자 개입: "DMA가 문제 아닐까?" → 근본 원인 발견
```

**문제점:**
- 각 세션마다 이전 설계 결정의 "의도"를 모름
- 왜 DMA를 선택했는지 기록 없음
- 실패한 시도들이 누적되지 않음

### 1.3 사용자의 블라인드 트러스트

```
사용자: "AI가 만들었으니 잘 만들었겠지"
  ↓
AI: DMA 구현 (복잡하지만 "표준적")
  ↓
사용자: DMA로 되어 있는지조차 모름
  ↓
문제 발생: 원인 파악 어려움
```

---

## 2. "시야가 좁다" - 구체적 분석

### 2.1 국지적 문제 해결

**사례: USB CDC 출력 문제**
```
문제 발견: "spi_protocol.c에서 USB CDC 출력 안됨"

AI의 좁은 시야:
├─ spi_protocol.c만 수정
├─ uart_send_response() 추가 ← 국지적 해결
└─ 끝

놓친 것들:
├─ spi_test_simple.c도 영향받음 ✗
├─ command_handler.c의 호출도 문제 ✗
├─ DMA vs 폴링 근본 설계 검토 ✗
└─ 전체 SPI 아키텍처 재검토 ✗
```

### 2.2 사이드 이펙트 고려 부족

**실제 발생한 문제:**
```c
// 문제: 디버그 출력 필요
// AI 해결:
spi_protocol.c에 uart_send_response() 추가

사이드 이펙트 (예상 못함):
├─ USB CDC TxState blocking 발생
├─ DMA 전송 중 50ms 대기 시간 추가
├─ 인터럽트 타이밍 충돌
└─ 결과: 더 큰 문제 발생
```

**왜 놓치는가:**
- **동적 분석 불가능**: 코드를 실행하며 "느낌"을 못받음
- **타이밍/동시성 파악 어려움**: 런타임 동작 예측 실패
- **레이어 간 상호작용 파악 부족**: 각 레이어는 이해하지만 상호작용 놓침

### 2.3 이전 실패 방법으로 회귀

**발생 메커니즘:**
```
세션 1:
문제 → 방법 A 시도 → 실패 → 방법 B 시도 → 성공!
  ↓ [세션 종료]
세션 2:
Claude: "방법 A가 좋아 보이는데?" (이전 실패 모름)
  ↓
사용자: "아 그거 안된다고..." (다시 설명)
```

**AI 메모리 구조:**
```
시도한 방법들:
├─ 방법 A (실패, 이유: X)
├─ 방법 B (실패, 이유: Y)
└─ 방법 C (성공!) ✓

AI 메모리:
└─ (없음)  ← 문제!
```

### 2.4 사용자가 해결책 제시해야 함

**언제 발생:**
- AI가 막다른 길에 도달
- 근본 원인을 파악하지 못함
- 패턴 인식만으로 해결 안될 때

**오늘 사례:**
```
AI: DMA + 디버그 출력 추가 → 더 악화
  ↓ (계속 시도)
사용자: "DMA가 문제 아닐까? 폴링으로 바꾸자"
  ↓
AI: 폴링 모드 변경 → 해결!
```

**이유:**
```
AI의 강점: 패턴 인식, 코드 생성
AI의 약점: 창의적 사고, 문제 재정의

사람의 강점: 직관, 창의성, 통찰력
```

---

## 3. 근본 원인 분석

### 3.1 AI vs 사람 개발자 비교

| 요소 | 사람 개발자 | AI 어시스턴트 |
|------|------------|--------------|
| 아키텍처 파악 | ✅ 전체 맥락 이해 | ⚠️ 파편적 이해 |
| 요구사항 분석 | ✅ "왜"를 파악 | ⚠️ "무엇"만 파악 |
| 트레이드오프 | ✅ 실용성 우선 | ⚠️ "정석" 우선 |
| 기술 선택 | ✅ 단순함 선호 | ⚠️ 복잡한 것도 OK |
| 상태 유지 | ✅ 프로젝트 히스토리 기억 | ❌ 세션마다 리셋 |
| 사이드 이펙트 | ✅ 런타임 경험으로 예측 | ❌ 정적 분석만 가능 |

### 3.2 Token/Context 제약

**구조적 한계:**
```
사람 개발자의 사고:
문제 → [넓은 맥락에서 분석] → 해결
    ↓
  전체 시스템
  관련 모듈들
  부작용 검토
  설계 검증

AI의 사고:
문제 → [국지적 패턴 매칭] → 해결
    ↓
  해당 파일만
  비슷한 예제 찾기
  코드 생성
```

**제약 사항:**
- 한 번에 처리할 수 있는 정보량 제한
- 전체 코드베이스를 동시에 "머릿속에 둘 수 없음"
- 관련 파일 찾기 어려움

---

## 4. 실용적 해결 방안

### 4.1 대화 전략

#### A. 명확한 컨텍스트 제공

**나쁜 요청:**
```
"SPI 전송이 안돼"
```

**좋은 요청:**
```
"SPI 폴링 모드로 데이터 전송 중인데,
 USB CDC로 디버그 출력하면 전송이 멈춰.
 SPI는 1개만 사용, 동시 전송 없음.
 인터럽트 우선순위: USB OTG=1, DMA=2"
```

#### B. 제약사항 먼저 명시

**요청 템플릿:**
```markdown
## 요청사항
[구체적 기능 설명]

## 제약사항
- 단순함 우선: 예
- 성능 요구사항: [구체적 수치]
- 금지 사항: DMA 사용 금지 (이유: 인터럽트 충돌)

## 시스템 컨텍스트
- 관련 모듈: SPI1, USB CDC
- 동시 사용 기능: USB CDC 디버그 출력
- 인터럽트 사용: USB OTG (우선순위 1)

## 이미 시도한 것
1. ❌ printf() - UART2 고장
2. ❌ uart_send_response() - blocking 문제

## 선호하는 방향
폴링 모드로 간단하게 구현
```

#### C. 단계별 검증 요청

```
❌ "전체 구현해줘" → AI가 알아서 → 문제 발생

✅ 단계별 접근:
1. "설계안 3가지 제시해줘 (장단점 포함)"
2. [사용자 검토 및 선택]
3. "A안으로 구현, 단 B안 호환성 유지해줘"
4. [테스트]
5. "문제 발생 시 B안으로 전환 가능하게 해줘"
```

### 4.2 문서화 전략

#### A. DECISIONS.md 유지

```markdown
# 설계 결정 기록

## 2025-01-08: SPI 폴링 모드 변경

### 문제
- DMA 모드에서 USB CDC 인터럽트 충돌

### 시도한 방법
1. ❌ printf() 추가 → UART2 고장
2. ❌ uart_send_response() 추가 → blocking 문제
3. ❌ 인터럽트 우선순위 조정 → 효과 없음

### 최종 해결
✅ DMA → 폴링 모드 변경

### 이유
- SPI 1개만 사용, 동시 전송 불필요
- 폴링 모드로 충분한 성능
- 코드 단순화, 디버깅 용이

### 사이드 이펙트 체크
- ✅ spi_test_simple.c 수정
- ✅ spi_wait_dma_complete() 호환성 유지
- ✅ 콜백 함수 유지 (빈 구현)
```

#### B. TODO.md로 추적

```markdown
# 진행 중인 작업

## 현재 작업
- [x] SPI DMA → 폴링 변경
- [ ] 실제 하드웨어 테스트
- [ ] 성능 측정

## 시도했지만 실패한 것들
- ❌ DMA + uart_send_response() (이유: 인터럽트 충돌)
- ❌ printf() 출력 (이유: UART2 고장)

## 다음에 시도할 것
- [ ] 실제 Slave 보드 연결 테스트
- [ ] 대용량 데이터 전송 성능 측정
```

### 4.3 AI 활용 전략

#### A. "설계 리뷰어"로 활용

```
사용자가 먼저 방향 제시:
"SPI 폴링으로 바꾸려고 하는데,
 놓칠 수 있는 부분 알려줘"

AI 응답:
- 관련 파일 목록
- 수정 필요한 함수들
- 잠재적 사이드 이펙트
- 테스트 체크리스트
```

#### B. "체크리스트 생성기"로 활용

```
요청:
"spi_send_data_dma()를 폴링으로 바꿀 때
 확인해야 할 체크리스트 만들어줘"

AI 응답:
✓ 체크리스트:
  □ spi_protocol.c 수정
  □ spi_test_simple.c 수정
  □ spi_wait_dma_complete() 호환성
  □ 콜백 함수 처리
  □ 인터럽트 핸들러 정리
  □ 빌드 테스트
  □ 실제 하드웨어 테스트
```

#### C. "디버그 어시스턴트"로 활용

```
문제 발생 시:
"SPITEST DATA 0 실행하면 USB CDC 출력 안됨

 [로그 첨부]
 [관련 코드 첨부]

 가능한 원인 5가지 알려줘"

→ 사용자가 판단 후 방향 제시
```

### 4.4 검증 프로세스

**단계별 검증:**
```
AI가 코드 생성
  ↓
1. 사용자 코드 리뷰
   - "이해되나?"
   - "왜 이렇게 했지?"
   - "더 간단한 방법은?"
  ↓
2. 사이드 이펙트 체크
   - "다른 파일 영향은?"
   - "인터럽트 충돌은?"
   - "성능 영향은?"
  ↓
3. 빌드 테스트
  ↓
4. 기능 테스트
  ↓
5. 문서 업데이트
   - DECISIONS.md
   - TODO.md
```

---

## 5. 핵심 원칙

### 5.1 KISS (Keep It Simple, Stupid)
- 복잡한 방법보다 단순한 방법 우선
- DMA가 "정석"이어도, 폴링이 "충분"하면 폴링 선택

### 5.2 YAGNI (You Aren't Gonna Need It)
- 지금 필요 없으면 만들지 마라
- "나중에 필요할 수도"는 금물

### 5.3 명확한 커뮤니케이션
- "간단하게", "폴링으로", "최소한의 기능만" 명시
- 제약사항 먼저 전달

### 5.4 AI = 도구, 사용자 = 운전자

**역할 분담:**
```
┌─────────────┬──────────────┐
│  사용자     │  AI          │
├─────────────┼──────────────┤
│ 방향 설정   │ 코드 생성    │
│ 설계 결정   │ 패턴 적용    │
│ 검증        │ 구현         │
│ 통찰        │ 반복 작업    │
└─────────────┴──────────────┘
```

### 5.5 "AI 코드 = 초안"

**AI 코드는:**
- ✅ 시작점
- ✅ 아이디어 제공
- ❌ 최종 솔루션

**사용자가 해야 할 것:**
1. 읽고 이해하기
2. 개선하기
3. 검증하기
4. 문서화하기

---

## 6. 즉시 적용 가이드

### 6.1 오늘부터 할 것

1. **DECISIONS.md 시작**
   - 설계 결정 기록
   - 실패한 시도도 기록

2. **요청 템플릿 사용**
   - 제약사항 먼저 명시
   - 이미 시도한 것 알려주기

3. **단계별 검증 습관**
   - AI 코드 → 읽고 이해 → 테스트 → 문서화

4. **방향은 사용자가 제시**
   - AI는 실행 도구
   - 설계 결정은 사용자

### 6.2 장기적으로 할 것

1. **코드 이해도 높이기**
   - AI가 만든 코드 반드시 읽기
   - "왜 이렇게 했지?" 질문하기

2. **시스템 전체 관점 유지**
   - AI는 부분만 보는 경향
   - 사용자가 전체를 봐야 함

3. **패턴 학습**
   - AI가 자주 놓치는 것들 패턴화
   - 체크리스트로 만들기

---

## 7. 이번 케이스에서 배운 교훈

### 7.1 문제 발생 과정

```
초기: AI가 DMA 구현 (over-engineering)
  ↓
중간: 세션 단절로 컨텍스트 손실
  ↓
디버깅: 증상만 보고 땜질 (더 악화)
  ↓
해결: 사용자가 근본 원인 파악 → 폴링 모드 변경
```

### 7.2 핵심 인사이트

1. **AI는 "정석"을 따르려 하지만, "실용성"을 놓칠 수 있다**
2. **세션 단절 = 컨텍스트 손실 = 일관성 깨짐 위험**
3. **사용자가 AI 코드를 이해하지 못하면 = 블랙박스 = 위험**

### 7.3 최종 해결책

```c
// Before (DMA - 복잡)
HAL_SPI_Transmit_DMA()
spi_dma_busy 플래그 관리
HAL_SPI_TxCpltCallback() 콜백
USB CDC 인터럽트 충돌

// After (폴링 - 단순)
HAL_SPI_Transmit()
플래그 불필요
콜백 불필요
충돌 해결
```

**이점:**
- ✅ USB CDC 충돌 해결
- ✅ 코드 단순화
- ✅ 디버깅 용이
- ✅ 성능 문제 없음 (SPI 1개만 사용)

---

## 8. 펌웨어 vs 파이썬: 왜 펌웨어가 더 어려운가?

### 8.1 실제 경험: 세션이 너무 빠르게 끝남

**관찰:**
- 파이썬: 세션이 길게 유지됨 (대화 50-100회)
- 펌웨어: 세션이 빠르게 끝남 (대화 10-20회)
- 원하는 결과까지 훨씬 많은 시간과 노력 필요

### 8.2 Token 소모 속도 비교

#### **파일당 Token 소모**

**파이썬:**
```python
# 파일 1개: ~100-500 토큰
def process_data(data):
    result = []
    for item in data:
        result.append(item * 2)
    return result

# 간결한 코드, 적은 보일러플레이트
```

**펌웨어 (STM32):**
```c
// 파일 1개: ~2,000-5,000 토큰

/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * Copyright (c) 2025 STMicroelectronics.
  * (수십 줄 주석...)
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "string.h"
#include "fatfs.h"
// ... 10개 이상의 include

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

// 실제 코드 시작하기도 전에 이미 수백 토큰 소모
```

#### **작업별 Token 소모**

| 작업 | 파이썬 | 펌웨어 (STM32) |
|------|--------|----------------|
| 파일 1개 읽기 | 100-500 | 2,000-5,000 |
| 함수 1개 구현 | 200-800 | 1,000-3,000 |
| 디버깅 1회 | 500-1,500 | 3,000-10,000 |
| 전체 대화 | 10,000-30,000 | 50,000-150,000 |

#### **펌웨어가 Token을 많이 쓰는 이유**

**필수로 읽어야 할 파일들:**
```
문제 해결을 위해 읽어야 하는 파일들:

펌웨어:
├─ main.c (2,000 토큰)
├─ stm32h7xx_it.c (1,500 토큰)
├─ stm32h7xx_hal_msp.c (3,000 토큰)
├─ spi_protocol.h/c (2,000 토큰)
├─ user_def.h/c (4,000 토큰)
├─ uart_command.h/c (3,000 토큰)
├─ HAL 드라이버 헤더들 (각 500-1,000 토큰)
└─ 하드웨어 레퍼런스 필요 시 추가...
→ 한 번 디버깅에 10,000-20,000 토큰 소모
→ 대화 5-10회면 Token limit 도달

파이썬:
├─ main.py (500 토큰)
├─ utils.py (300 토큰)
└─ 끝
→ 한 번 디버깅에 1,000-2,000 토큰
→ 대화 50-100회 가능
```

### 8.3 복잡도와 레이어 차이

#### **추상화 레벨**

**파이썬 (높은 추상화):**
```python
# 3줄로 HTTP 서버 구현
from flask import Flask
app = Flask(__name__)
app.run()

# AI가 이해하기 쉬움:
# - 명확한 의도
# - 숨겨진 복잡도 없음
# - 동작 예측 가능
```

**펌웨어 (낮은 추상화):**
```c
// SPI 전송 하나를 위해 알아야 할 것들:

1. 하드웨어 레이어
   - SPI1 페리페럴 설정
   - GPIO 핀 매핑 (MOSI, MISO, SCK, CS)
   - 클럭 설정 (APB2, Prescaler)
   - DMA 채널 할당

2. HAL 레이어
   - HAL_SPI_Init()
   - HAL_SPI_MspInit()
   - DMA vs 폴링 모드 선택

3. 인터럽트 레이어
   - NVIC 우선순위
   - DMA 인터럽트
   - SPI 인터럽트

4. 메모리 레이어
   - DMA 버퍼 메모리 영역
   - 캐시 일관성
   - 메모리 정렬

5. 타이밍 레이어
   - CS 핀 타이밍
   - 데이터 셋업/홀드 타임

→ AI가 모든 레이어를 동시에 고려하기 어려움
```

#### **컨텍스트 의존성**

**파이썬:**
```python
# 함수 하나만 봐도 이해 가능
def add(a, b):
    return a + b
# 독립적, 자명함
```

**펌웨어:**
```c
// 함수 하나를 이해하려면...
HAL_SPI_Transmit()
  ↓ 의존
HAL_SPI_Init() 설정 확인 필요
  ↓ 의존
HAL_SPI_MspInit() 하드웨어 초기화 확인
  ↓ 의존
GPIO, DMA, 클럭 설정 확인
  ↓ 의존
하드웨어 데이터시트 참조

→ 함수 1개 이해에 5-10개 파일 필요
```

### 8.4 디버깅 환경의 차이

#### **즉각적 피드백**

**파이썬:**
```python
# 코드 작성
def test():
    print("Hello")

# 즉시 실행
$ python test.py
Hello
# → 1초 만에 결과 확인

# 에러 발생 시
$ python test.py
Traceback (most recent call last):
  File "test.py", line 2
    print("Hello"
          ^
SyntaxError: invalid syntax
# → 명확한 에러 메시지, 라인 번호
```

**펌웨어:**
```c
// 코드 작성

// 빌드
$ make
... 5-30초 대기 ...

// 플래시
$ STM32_Programmer_CLI ...
... 10-20초 대기 ...

// 하드웨어 연결 및 실행
... 리셋, 시리얼 연결 ...

// 문제 발생
→ 아무 출력 없음?
→ LED도 안켜짐?
→ 뭐가 문제?
  - 빌드는 성공했는데...
  - 하드웨어 문제?
  - 코드 문제?
  - 설정 문제?

→ 디버거 연결 필요
→ 한 사이클에 5-10분
```

#### **에러 메시지 품질**

**파이썬:**
```python
>>> data = None
>>> data.append(1)
AttributeError: 'NoneType' object has no attribute 'append'
#          ↑ 명확한 에러
```

**펌웨어:**
```c
// HardFault 발생
// → 프로그램 멈춤
// → 에러 메시지? 없음
// → 어디서 멈췄는지? 모름

// 가능한 원인:
// - NULL 포인터?
// - 스택 오버플로우?
// - 잘못된 메모리 접근?
// - DMA 설정 오류?
// - 클럭 설정 문제?
// → 디버거 없이는 알 수 없음
```

### 8.5 하드웨어 의존성

**파이썬:**
```python
# 모든 환경에서 동일하게 동작
import json
data = json.loads('{"key": "value"}')
# → 어디서든 같은 결과
```

**펌웨어:**
```c
// 같은 코드도...

// STM32H723에서는:
__HAL_RCC_GPIOF_CLK_ENABLE();  // ✓ 작동

// STM32F103에서는:
__HAL_RCC_GPIOF_CLK_ENABLE();  // ✗ 컴파일 에러
// (F103에는 GPIOF 없음)

// 보드마다:
// - 다른 GPIO 핀
// - 다른 클럭 주파수
// - 다른 페리페럴 설정
// - 다른 메모리 맵
```

### 8.6 근본적 차이 요약

| 측면 | 파이썬 | 펌웨어 |
|------|--------|--------|
| **추상화 레벨** | 높음 (간결) | 낮음 (복잡) |
| **Token/파일** | 100-500 | 2,000-5,000 |
| **디버깅 사이클** | 초 단위 | 분 단위 |
| **에러 메시지** | 명확 | 불명확 |
| **하드웨어 의존** | 없음 | 높음 |
| **테스트** | 쉬움 | 어려움 |
| **예제/문서** | 풍부 | 제한적 |
| **상태 복잡도** | 낮음 | 높음 |
| **AI 이해도** | 높음 | 낮음 |
| **세션 수명** | 길다 | 짧다 |

### 8.7 같은 기능 구현 비교

#### **HTTP API 만들기**

**파이썬:**
```python
# 5줄, 30초 작성
from flask import Flask, jsonify
app = Flask(__name__)

@app.route('/api/data')
def get_data():
    return jsonify({"status": "ok"})

app.run()

# AI 질의: 1-2회
# Token 소모: 1,000-2,000
# 세션: 1개로 완료
```

**펌웨어 (HTTP 서버):**
```c
// 수백 줄, 수 시간 작성

// 1. Ethernet 초기화 (HAL_ETH_Init)
// 2. LwIP 스택 초기화
// 3. HTTP 서버 구현
// 4. JSON 파싱 라이브러리 추가
// 5. 메모리 관리
// 6. 인터럽트 처리
// 7. RTOS 태스크 설정

// AI 질의: 20-50회
// Token 소모: 100,000-200,000
// 세션: 5-10개 필요
// 실제 테스트: 수십 번
```

### 8.8 AI CLI 도구별 Token 제한 비교

#### **주요 CLI 도구 Token 제한**

| CLI 도구 | 토큰 제한 | 펌웨어 개발 적합도 |
|----------|-----------|-------------------|
| **Gemini 2.0 Flash** | **1,000,000** | ⭐⭐⭐⭐⭐ 최고 |
| **Gemini 1.5 Pro** | **1,000,000** | ⭐⭐⭐⭐⭐ 최고 |
| **Claude Code** | **200,000** | ⭐⭐⭐⭐ 좋음 |
| GPT-4 Turbo | 128,000 | ⭐⭐⭐ 괜찮음 |
| GPT-4o | 128,000 | ⭐⭐⭐ 괜찮음 |
| GPT-4 (32K) | 32,768 | ⭐⭐ 부족 |
| Gemini 1.0 Pro | 32,768 | ⭐⭐ 부족 |
| GPT-4 (8K) | 8,192 | ⭐ 매우 부족 |

#### **펌웨어 개발 시나리오별 세션 수명**

**시나리오: STM32 프로젝트 디버깅**

```
필요한 파일 읽기:
- main.c (2,000)
- stm32h7xx_it.c (1,500)
- stm32h7xx_hal_msp.c (3,000)
- spi_protocol.c (2,000)
- user_def.c (4,000)
- uart_command.c (3,000)
────────────────────────────
총: 15,500 토큰

대화 진행:
- 초기 로드: 15,500
- 질문/답변 10회: 20,000
- 코드 수정 5회: 10,000
────────────────────────────
총 사용: 45,500 토큰
```

**각 CLI의 세션 수명:**

| CLI | 세션 수명 | 비고 |
|-----|-----------|------|
| GPT-4 (8K) | ❌ 즉시 초과 | 파일 읽기도 못함 |
| GPT-4 (32K) | ⚠️ 파일만 읽고 끝 | 대화 2-3회만 |
| Gemini 1.0 Pro | ⚠️ 파일만 읽고 끝 | 대화 2-3회만 |
| GPT-4 Turbo | ✅ 대화 15-20회 | 괜찮음 |
| **Claude Code** | ✅ 대화 20-30회 | 좋음 (현재 사용) |
| Gemini 1.5/2.0 | ✅✅ 대화 100+회 | 압도적 |

#### **Token별 실제 사용 예시**

**8K 토큰 (GPT-4 기본):**
```c
// main.c만 읽어도 초과
/* 헤더: 500 토큰 */
/* includes: 200 토큰 */
/* 변수: 500 토큰 */
/* 함수들: 1,000+ 토큰 */

→ 파일 1개도 제대로 못 읽음
→ 펌웨어에 부적합
```

**32K 토큰 (GPT-4 32K, Gemini 1.0):**
```c
// 파일 3-5개 정도만 가능
→ 빠듯하게 가능하지만 자주 리셋 필요
```

**200K 토큰 (Claude Code - 현재):**
```c
// 파일 20-30개 가능
// 대화 20-30회 가능
→ 한 세션에서 충분히 작업 가능
→ 이번 세션: 100K 사용, 100K 남음
```

**1M 토큰 (Gemini 1.5/2.0):**
```c
// 파일 100-200개 가능
// 대화 100회 이상 가능
→ 사실상 제한 없음
→ 대규모 리팩토링도 가능
```

### 8.9 핵심: 왜 펌웨어가 더 힘든가?

#### **1. Token 폭탄**
```
펌웨어 파일 =
  HAL 보일러플레이트 (1,000)
  + 실제 코드 (500)
  + 주석/헤더 (500)
  = 2,000+ 토큰/파일

→ 파일 10개 = 20,000 토큰
→ 대화 5-10회면 limit
```

#### **2. 컨텍스트 폭발**
```
하나 고치려면:
- 하드웨어 이해
- HAL 구조 이해
- 인터럽트 이해
- 메모리 맵 이해
- 타이밍 이해
→ AI 처리 한계 초과
```

#### **3. 피드백 지연**
```
파이썬: 코드 → 실행 (1초) → 결과

펌웨어: 코드 → 빌드 (30초) → 플래시 (20초)
        → 하드웨어 테스트 (분) → 결과

→ AI가 "학습"하며 개선하기 어려움
```

### 8.10 현실적 대처 방법

#### **1. 파일 크기 줄이기**
```c
// main.c를 작게 유지
// USER CODE 부분만 집중
// 필요한 부분만 AI에게 보여주기
```

#### **2. 명확한 범위 지정**
```
❌ "SPI 통신 구현해줘"
✅ "spi_send_data() 함수만 폴링 모드로 수정,
    이미 초기화는 되어 있음,
    HAL_SPI_Transmit() 사용"
```

#### **3. 단계별 진행**
```
한 번에 하나씩:
1. 함수 1개 구현
2. 테스트
3. 다음 함수

vs ❌ 전체 시스템 한 번에
```

#### **4. 컨텍스트 재사용**
```
새 세션마다:
"이전에 SPI를 폴링 모드로 구현했어.
 spi_protocol.c 파일 참고해서
 이번엔 UART도 같은 방식으로 해줘"

→ 이전 결정 재활용
```

### 8.11 펌웨어 개발 권장 AI 도구

**1순위: Gemini 1.5 Pro / 2.0 Flash**
```
장점:
✅ 1M 토큰 - 압도적
✅ 전체 프로젝트 로드 가능
✅ 컨텍스트 손실 걱정 없음
✅ 속도도 빠름 (2.0 Flash)

단점:
⚠️ 코드 생성 품질은 Claude만큼 아닐 수 있음
⚠️ CLI 도구 성숙도 (Claude가 더 안정적)
```

**2순위: Claude Code (현재 사용 중)**
```
장점:
✅ 200K 토큰 - 충분
✅ 코드 생성 품질 우수
✅ 펌웨어 이해도 높음
✅ 안정적인 CLI 도구

단점:
⚠️ 대규모 프로젝트에서는 토큰 관리 필요
```

**3순위: GPT-4 Turbo**
```
장점:
✅ 128K 토큰 - 괜찮음
✅ 빠른 응답

단점:
⚠️ Claude보다 토큰 적음
⚠️ 펌웨어 이해도는 Claude만큼 안될 수 있음
```

---

## 결론

**AI 코딩 어시스턴트는 강력한 도구이지만:**
- 과도한 엔지니어링 경향
- 세션 단절 시 컨텍스트 손실
- 좁은 시야, 사이드 이펙트 간과
- 사용자의 통찰력과 방향 제시 필요

**펌웨어 개발에서 특히 어려운 이유:**
- Token 소모 10-20배 많음 (보일러플레이트, 복잡도)
- 컨텍스트 의존성 높음 (하드웨어, HAL, 메모리...)
- 디버깅 사이클 느림 (빌드-플래시-테스트)
- 에러 피드백 불명확 (HardFault, 무응답...)

**성공적인 AI 활용 핵심:**
- **운전대는 사용자가 잡기**
- **AI = 도구, 사용자 = 설계자**
- **단순함 우선, 문서화 필수**
- **코드 이해 → 검증 → 개선**
- **작은 단위로 쪼개기**
- **명확한 범위 지정**

---

## 참고: 요청 템플릿

### 기능 요청 템플릿
```markdown
## 요청사항
[구체적 기능 설명]

## 제약사항
- 단순함 우선: [예/아니오]
- 성능 요구사항: [구체적 수치]
- 금지 사항: [사용하면 안 되는 방법]

## 시스템 컨텍스트
- 관련 모듈: [목록]
- 동시 사용 기능: [목록]
- 인터럽트 사용: [목록과 우선순위]

## 이미 시도한 것
1. ❌ [방법] - [실패 이유]
2. ❌ [방법] - [실패 이유]

## 선호하는 방향
[구체적 아이디어가 있으면]
```

### 디버깅 요청 템플릿
```markdown
## 문제 증상
[구체적 설명]

## 재현 방법
1. [단계별]

## 예상 vs 실제
- 예상: [...]
- 실제: [...]

## 관련 코드
[코드 첨부]

## 이미 시도한 것
1. ❌ [방법] - [결과]

## 질문
가능한 원인 [N]가지 알려주고,
각각에 대한 검증 방법도 알려줘
```

---

**작성**: Claude Code
**검토**: 사용자 경험 기반
**버전**: 1.0
